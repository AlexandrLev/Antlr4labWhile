//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.10.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from lab4.g4 by ANTLR 4.10.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class lab4Parser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		WS=1, Typenumber=2, Typereal=3, Typechar=4, Typebool=5, Constnumber=6, 
		Constreal=7, Constchar=8, Constbool=9, Constseven=10, Exp=11, ArifmOp=12, 
		ArifmOpExt=13, LogOp=14, LbParam=15, RbParam=16, LfBracket=17, RfBracket=18, 
		LineSep=19, Prisv=20, IdentSep=21, While=22, Do=23, End=24, Ident=25;
	public const int
		RULE_main = 0, RULE_statement = 1, RULE_whiledo = 2, RULE_whilecondition = 3, 
		RULE_dobody = 4, RULE_declaration = 5, RULE_assign = 6, RULE_arifmoperation = 7, 
		RULE_typedata = 8, RULE_const = 9, RULE_operands = 10;
	public static readonly string[] ruleNames = {
		"main", "statement", "whiledo", "whilecondition", "dobody", "declaration", 
		"assign", "arifmoperation", "typedata", "const", "operands"
	};

	private static readonly string[] _LiteralNames = {
		null, null, "'number'", "'real'", null, "'bool'", null, null, null, null, 
		null, null, null, null, null, "'('", "')'", "'{'", "'}'", "';'", "':='", 
		"','", "'while'", "'do'", "'end'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "WS", "Typenumber", "Typereal", "Typechar", "Typebool", "Constnumber", 
		"Constreal", "Constchar", "Constbool", "Constseven", "Exp", "ArifmOp", 
		"ArifmOpExt", "LogOp", "LbParam", "RbParam", "LfBracket", "RfBracket", 
		"LineSep", "Prisv", "IdentSep", "While", "Do", "End", "Ident"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "lab4.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static lab4Parser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public lab4Parser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public lab4Parser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class MainContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext[] declaration() {
			return GetRuleContexts<DeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration(int i) {
			return GetRuleContext<DeclarationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public MainContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.EnterMain(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.ExitMain(this);
		}
	}

	[RuleVersion(0)]
	public MainContext main() {
		MainContext _localctx = new MainContext(Context, State);
		EnterRule(_localctx, 0, RULE_main);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 25;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Typenumber) | (1L << Typereal) | (1L << Typechar) | (1L << Typebool))) != 0)) {
				{
				{
				State = 22;
				declaration();
				}
				}
				State = 27;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 31;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==While || _la==Ident) {
				{
				{
				State = 28;
				statement();
				}
				}
				State = 33;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignContext assign() {
			return GetRuleContext<AssignContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhiledoContext whiledo() {
			return GetRuleContext<WhiledoContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 2, RULE_statement);
		try {
			State = 36;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Ident:
				EnterOuterAlt(_localctx, 1);
				{
				State = 34;
				assign();
				}
				break;
			case While:
				EnterOuterAlt(_localctx, 2);
				{
				State = 35;
				whiledo();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhiledoContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode While() { return GetToken(lab4Parser.While, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WhileconditionContext whilecondition() {
			return GetRuleContext<WhileconditionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Do() { return GetToken(lab4Parser.Do, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DobodyContext dobody() {
			return GetRuleContext<DobodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public WhiledoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whiledo; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.EnterWhiledo(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.ExitWhiledo(this);
		}
	}

	[RuleVersion(0)]
	public WhiledoContext whiledo() {
		WhiledoContext _localctx = new WhiledoContext(Context, State);
		EnterRule(_localctx, 4, RULE_whiledo);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 38;
			Match(While);
			State = 39;
			whilecondition();
			State = 40;
			Match(Do);
			State = 41;
			dobody();
			State = 45;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 42;
					statement();
					}
					} 
				}
				State = 47;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileconditionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LbParam() { return GetToken(lab4Parser.LbParam, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RbParam() { return GetToken(lab4Parser.RbParam, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Constbool() { return GetTokens(lab4Parser.Constbool); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constbool(int i) {
			return GetToken(lab4Parser.Constbool, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OperandsContext[] operands() {
			return GetRuleContexts<OperandsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OperandsContext operands(int i) {
			return GetRuleContext<OperandsContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LogOp() { return GetToken(lab4Parser.LogOp, 0); }
		public WhileconditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whilecondition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.EnterWhilecondition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.ExitWhilecondition(this);
		}
	}

	[RuleVersion(0)]
	public WhileconditionContext whilecondition() {
		WhileconditionContext _localctx = new WhileconditionContext(Context, State);
		EnterRule(_localctx, 6, RULE_whilecondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 48;
			Match(LbParam);
			State = 51;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 49;
				Match(Constbool);
				}
				break;
			case 2:
				{
				State = 50;
				operands();
				}
				break;
			}
			State = 58;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LogOp) {
				{
				State = 53;
				Match(LogOp);
				State = 56;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
				case 1:
					{
					State = 54;
					Match(Constbool);
					}
					break;
				case 2:
					{
					State = 55;
					operands();
					}
					break;
				}
				}
			}

			State = 60;
			Match(RbParam);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DobodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LfBracket() { return GetToken(lab4Parser.LfBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RfBracket() { return GetToken(lab4Parser.RfBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public DobodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dobody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.EnterDobody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.ExitDobody(this);
		}
	}

	[RuleVersion(0)]
	public DobodyContext dobody() {
		DobodyContext _localctx = new DobodyContext(Context, State);
		EnterRule(_localctx, 8, RULE_dobody);
		int _la;
		try {
			State = 71;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LfBracket:
				EnterOuterAlt(_localctx, 1);
				{
				State = 62;
				Match(LfBracket);
				State = 66;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==While || _la==Ident) {
					{
					{
					State = 63;
					statement();
					}
					}
					State = 68;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 69;
				Match(RfBracket);
				}
				break;
			case While:
			case Ident:
				EnterOuterAlt(_localctx, 2);
				{
				State = 70;
				statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypedataContext typedata() {
			return GetRuleContext<TypedataContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Ident() { return GetTokens(lab4Parser.Ident); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ident(int i) {
			return GetToken(lab4Parser.Ident, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LineSep() { return GetToken(lab4Parser.LineSep, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] IdentSep() { return GetTokens(lab4Parser.IdentSep); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IdentSep(int i) {
			return GetToken(lab4Parser.IdentSep, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Typenumber() { return GetToken(lab4Parser.Typenumber, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Prisv() { return GetToken(lab4Parser.Prisv, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constnumber() { return GetToken(lab4Parser.Constnumber, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Typereal() { return GetToken(lab4Parser.Typereal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constreal() { return GetToken(lab4Parser.Constreal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Typechar() { return GetToken(lab4Parser.Typechar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constchar() { return GetToken(lab4Parser.Constchar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Typebool() { return GetToken(lab4Parser.Typebool, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constbool() { return GetToken(lab4Parser.Constbool, 0); }
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(Context, State);
		EnterRule(_localctx, 10, RULE_declaration);
		int _la;
		try {
			State = 104;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 73;
				typedata();
				State = 74;
				Match(Ident);
				State = 79;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==IdentSep) {
					{
					{
					State = 75;
					Match(IdentSep);
					State = 76;
					Match(Ident);
					}
					}
					State = 81;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 82;
				Match(LineSep);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 84;
				Match(Typenumber);
				State = 85;
				Match(Ident);
				State = 86;
				Match(Prisv);
				State = 87;
				Match(Constnumber);
				State = 88;
				Match(LineSep);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 89;
				Match(Typereal);
				State = 90;
				Match(Ident);
				State = 91;
				Match(Prisv);
				State = 92;
				Match(Constreal);
				State = 93;
				Match(LineSep);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 94;
				Match(Typechar);
				State = 95;
				Match(Ident);
				State = 96;
				Match(Prisv);
				State = 97;
				Match(Constchar);
				State = 98;
				Match(LineSep);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 99;
				Match(Typebool);
				State = 100;
				Match(Ident);
				State = 101;
				Match(Prisv);
				State = 102;
				Match(Constbool);
				State = 103;
				Match(LineSep);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ident() { return GetToken(lab4Parser.Ident, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Prisv() { return GetToken(lab4Parser.Prisv, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OperandsContext operands() {
			return GetRuleContext<OperandsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LineSep() { return GetToken(lab4Parser.LineSep, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public AssignContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assign; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.EnterAssign(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.ExitAssign(this);
		}
	}

	[RuleVersion(0)]
	public AssignContext assign() {
		AssignContext _localctx = new AssignContext(Context, State);
		EnterRule(_localctx, 12, RULE_assign);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 106;
			Match(Ident);
			State = 107;
			Match(Prisv);
			State = 108;
			operands();
			State = 109;
			Match(LineSep);
			State = 113;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 110;
					statement();
					}
					} 
				}
				State = 115;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArifmoperationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ArifmOp() { return GetToken(lab4Parser.ArifmOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OperandsContext operands() {
			return GetRuleContext<OperandsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ident() { return GetToken(lab4Parser.Ident, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstContext @const() {
			return GetRuleContext<ConstContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ArifmOpExt() { return GetToken(lab4Parser.ArifmOpExt, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LbParam() { return GetToken(lab4Parser.LbParam, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArifmoperationContext arifmoperation() {
			return GetRuleContext<ArifmoperationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RbParam() { return GetToken(lab4Parser.RbParam, 0); }
		public ArifmoperationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arifmoperation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.EnterArifmoperation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.ExitArifmoperation(this);
		}
	}

	[RuleVersion(0)]
	public ArifmoperationContext arifmoperation() {
		ArifmoperationContext _localctx = new ArifmoperationContext(Context, State);
		EnterRule(_localctx, 14, RULE_arifmoperation);
		try {
			State = 128;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,13,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 118;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case Ident:
					{
					State = 116;
					Match(Ident);
					}
					break;
				case Constnumber:
				case Constreal:
				case Constchar:
				case Constbool:
				case Constseven:
					{
					State = 117;
					@const();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 120;
				Match(ArifmOp);
				State = 121;
				operands();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 122;
				Match(Ident);
				State = 123;
				Match(ArifmOpExt);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 124;
				Match(LbParam);
				State = 125;
				arifmoperation();
				State = 126;
				Match(RbParam);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedataContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Typenumber() { return GetToken(lab4Parser.Typenumber, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Typereal() { return GetToken(lab4Parser.Typereal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Typechar() { return GetToken(lab4Parser.Typechar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Typebool() { return GetToken(lab4Parser.Typebool, 0); }
		public TypedataContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedata; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.EnterTypedata(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.ExitTypedata(this);
		}
	}

	[RuleVersion(0)]
	public TypedataContext typedata() {
		TypedataContext _localctx = new TypedataContext(Context, State);
		EnterRule(_localctx, 16, RULE_typedata);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 130;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Typenumber) | (1L << Typereal) | (1L << Typechar) | (1L << Typebool))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constnumber() { return GetToken(lab4Parser.Constnumber, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constreal() { return GetToken(lab4Parser.Constreal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constchar() { return GetToken(lab4Parser.Constchar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constbool() { return GetToken(lab4Parser.Constbool, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constseven() { return GetToken(lab4Parser.Constseven, 0); }
		public ConstContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_const; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.EnterConst(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.ExitConst(this);
		}
	}

	[RuleVersion(0)]
	public ConstContext @const() {
		ConstContext _localctx = new ConstContext(Context, State);
		EnterRule(_localctx, 18, RULE_const);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Constnumber) | (1L << Constreal) | (1L << Constchar) | (1L << Constbool) | (1L << Constseven))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperandsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ident() { return GetToken(lab4Parser.Ident, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstContext @const() {
			return GetRuleContext<ConstContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArifmoperationContext arifmoperation() {
			return GetRuleContext<ArifmoperationContext>(0);
		}
		public OperandsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operands; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.EnterOperands(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			Ilab4Listener typedListener = listener as Ilab4Listener;
			if (typedListener != null) typedListener.ExitOperands(this);
		}
	}

	[RuleVersion(0)]
	public OperandsContext operands() {
		OperandsContext _localctx = new OperandsContext(Context, State);
		EnterRule(_localctx, 20, RULE_operands);
		try {
			State = 137;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,14,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 134;
				Match(Ident);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 135;
				@const();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 136;
				arifmoperation();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,25,140,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,1,0,5,0,24,8,0,10,0,12,0,27,9,0,1,0,5,0,
		30,8,0,10,0,12,0,33,9,0,1,1,1,1,3,1,37,8,1,1,2,1,2,1,2,1,2,1,2,5,2,44,
		8,2,10,2,12,2,47,9,2,1,3,1,3,1,3,3,3,52,8,3,1,3,1,3,1,3,3,3,57,8,3,3,3,
		59,8,3,1,3,1,3,1,4,1,4,5,4,65,8,4,10,4,12,4,68,9,4,1,4,1,4,3,4,72,8,4,
		1,5,1,5,1,5,1,5,5,5,78,8,5,10,5,12,5,81,9,5,1,5,1,5,1,5,1,5,1,5,1,5,1,
		5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,105,
		8,5,1,6,1,6,1,6,1,6,1,6,5,6,112,8,6,10,6,12,6,115,9,6,1,7,1,7,3,7,119,
		8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,129,8,7,1,8,1,8,1,9,1,9,1,10,1,
		10,1,10,3,10,138,8,10,1,10,0,0,11,0,2,4,6,8,10,12,14,16,18,20,0,2,1,0,
		2,5,1,0,6,10,148,0,25,1,0,0,0,2,36,1,0,0,0,4,38,1,0,0,0,6,48,1,0,0,0,8,
		71,1,0,0,0,10,104,1,0,0,0,12,106,1,0,0,0,14,128,1,0,0,0,16,130,1,0,0,0,
		18,132,1,0,0,0,20,137,1,0,0,0,22,24,3,10,5,0,23,22,1,0,0,0,24,27,1,0,0,
		0,25,23,1,0,0,0,25,26,1,0,0,0,26,31,1,0,0,0,27,25,1,0,0,0,28,30,3,2,1,
		0,29,28,1,0,0,0,30,33,1,0,0,0,31,29,1,0,0,0,31,32,1,0,0,0,32,1,1,0,0,0,
		33,31,1,0,0,0,34,37,3,12,6,0,35,37,3,4,2,0,36,34,1,0,0,0,36,35,1,0,0,0,
		37,3,1,0,0,0,38,39,5,22,0,0,39,40,3,6,3,0,40,41,5,23,0,0,41,45,3,8,4,0,
		42,44,3,2,1,0,43,42,1,0,0,0,44,47,1,0,0,0,45,43,1,0,0,0,45,46,1,0,0,0,
		46,5,1,0,0,0,47,45,1,0,0,0,48,51,5,15,0,0,49,52,5,9,0,0,50,52,3,20,10,
		0,51,49,1,0,0,0,51,50,1,0,0,0,52,58,1,0,0,0,53,56,5,14,0,0,54,57,5,9,0,
		0,55,57,3,20,10,0,56,54,1,0,0,0,56,55,1,0,0,0,57,59,1,0,0,0,58,53,1,0,
		0,0,58,59,1,0,0,0,59,60,1,0,0,0,60,61,5,16,0,0,61,7,1,0,0,0,62,66,5,17,
		0,0,63,65,3,2,1,0,64,63,1,0,0,0,65,68,1,0,0,0,66,64,1,0,0,0,66,67,1,0,
		0,0,67,69,1,0,0,0,68,66,1,0,0,0,69,72,5,18,0,0,70,72,3,2,1,0,71,62,1,0,
		0,0,71,70,1,0,0,0,72,9,1,0,0,0,73,74,3,16,8,0,74,79,5,25,0,0,75,76,5,21,
		0,0,76,78,5,25,0,0,77,75,1,0,0,0,78,81,1,0,0,0,79,77,1,0,0,0,79,80,1,0,
		0,0,80,82,1,0,0,0,81,79,1,0,0,0,82,83,5,19,0,0,83,105,1,0,0,0,84,85,5,
		2,0,0,85,86,5,25,0,0,86,87,5,20,0,0,87,88,5,6,0,0,88,105,5,19,0,0,89,90,
		5,3,0,0,90,91,5,25,0,0,91,92,5,20,0,0,92,93,5,7,0,0,93,105,5,19,0,0,94,
		95,5,4,0,0,95,96,5,25,0,0,96,97,5,20,0,0,97,98,5,8,0,0,98,105,5,19,0,0,
		99,100,5,5,0,0,100,101,5,25,0,0,101,102,5,20,0,0,102,103,5,9,0,0,103,105,
		5,19,0,0,104,73,1,0,0,0,104,84,1,0,0,0,104,89,1,0,0,0,104,94,1,0,0,0,104,
		99,1,0,0,0,105,11,1,0,0,0,106,107,5,25,0,0,107,108,5,20,0,0,108,109,3,
		20,10,0,109,113,5,19,0,0,110,112,3,2,1,0,111,110,1,0,0,0,112,115,1,0,0,
		0,113,111,1,0,0,0,113,114,1,0,0,0,114,13,1,0,0,0,115,113,1,0,0,0,116,119,
		5,25,0,0,117,119,3,18,9,0,118,116,1,0,0,0,118,117,1,0,0,0,119,120,1,0,
		0,0,120,121,5,12,0,0,121,129,3,20,10,0,122,123,5,25,0,0,123,129,5,13,0,
		0,124,125,5,15,0,0,125,126,3,14,7,0,126,127,5,16,0,0,127,129,1,0,0,0,128,
		118,1,0,0,0,128,122,1,0,0,0,128,124,1,0,0,0,129,15,1,0,0,0,130,131,7,0,
		0,0,131,17,1,0,0,0,132,133,7,1,0,0,133,19,1,0,0,0,134,138,5,25,0,0,135,
		138,3,18,9,0,136,138,3,14,7,0,137,134,1,0,0,0,137,135,1,0,0,0,137,136,
		1,0,0,0,138,21,1,0,0,0,15,25,31,36,45,51,56,58,66,71,79,104,113,118,128,
		137
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
